"""Code quality hook: PreToolUse — run typecheck/lint/test before git commit.

Config-driven: reads commands from .claude/quality-gate.json (generated by /project-workflow-init).
Fails open if config missing (warns but allows commit).
"""
import sys
import json
import re
import subprocess
import os


def main():
    data = json.load(sys.stdin)
    command = data.get("tool_input", {}).get("command", "")
    cwd = data.get("cwd", ".")

    # Only intercept git commit commands
    if not re.search(r"\bgit\s+commit\b", command):
        sys.exit(0)

    # Escape hatch: --no-verify bypasses quality checks
    if "--no-verify" in command:
        print(
            "Quality gate: --no-verify detected, skipping code quality checks.",
            file=sys.stderr,
        )
        sys.exit(0)

    # Read quality gate config
    config_path = os.path.join(cwd, ".claude", "quality-gate.json")
    if not os.path.isfile(config_path):
        print(
            "Quality gate WARNING: .claude/quality-gate.json not found, skipping code quality checks.",
            file=sys.stderr,
        )
        sys.exit(0)

    try:
        with open(config_path, "r", encoding="utf-8") as f:
            config = json.load(f)
    except (json.JSONDecodeError, OSError) as e:
        print(
            f"Quality gate WARNING: Failed to read config: {e}",
            file=sys.stderr,
        )
        sys.exit(0)

    commands = config.get("commands", {})
    timeout = config.get("timeout_seconds", 60)

    # Run quality checks sequentially: typecheck → lint → test
    gate_order = ["typecheck", "lint", "test"]
    bash_cmd = os.environ.get("CLAUDE_CODE_GIT_BASH_PATH", "bash")

    for gate in gate_order:
        cmd = commands.get(gate, "N/A")
        if not cmd or cmd == "N/A":
            continue

        try:
            result = subprocess.run(
                [bash_cmd, "-c", cmd],
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=cwd,
            )
        except subprocess.TimeoutExpired:
            reason = (
                f"Quality gate: {gate} timed out after {timeout}s.\n"
                f"Command: {cmd}\n"
                f"Fix the issue or use --no-verify to bypass."
            )
            json.dump(
                {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": reason,
                    }
                },
                sys.stdout,
            )
            sys.exit(0)
        except FileNotFoundError as e:
            print(
                f"Quality gate WARNING: Failed to run {gate}: {e}",
                file=sys.stderr,
            )
            continue

        if result.returncode != 0:
            # Collect error output (stderr first, fallback to stdout)
            error_output = result.stderr.strip() or result.stdout.strip()
            error_lines = error_output.splitlines()[:10]

            reason = f"Quality gate: {gate} FAILED. Fix before committing:\n"
            reason += f"  Command: {cmd}\n"
            for line in error_lines:
                reason += f"  {line}\n"
            if len(error_output.splitlines()) > 10:
                reason += f"  ... ({len(error_output.splitlines()) - 10} more lines)\n"
            reason += f"Run: {cmd} for full output."

            json.dump(
                {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": reason,
                    }
                },
                sys.stdout,
            )
            sys.exit(0)

    # All gates passed (or were N/A)
    sys.exit(0)


if __name__ == "__main__":
    main()
